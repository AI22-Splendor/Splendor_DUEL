#pragma once

#include <iostream>
#include "Gemmes.h"
#include "Bag.h"

using namespace std;

/**
* Handles the board of the game
*/
class Board {
public: 
	Board() {
		gems = new Gemmes[BOARD_SIZE];
		for (int i = 0; i < BOARD_SIZE; i++) {
			gems[i] = Gemmes::Vide;
		}
	}

	void remplirBoard(const Bag& bag) const;
	Gemmes& prendreGemme(const int pos) const;

	ostream& operator<<(ostream& os) {
		for (int i = 0; i < BOARD_SIDE; i++) {
			for (int j = 0; j < BOARD_SIDE; j++) {
				os << "  " << gems[i * BOARD_SIDE + j];
			}
			os << endl;
		}
		return os;
	}

private:
	static const unsigned int BOARD_SIDE = 5;
	static const unsigned int BOARD_SIZE = BOARD_SIDE * BOARD_SIDE;
	Gemmes* gems;
	friend class iterator;

	class iterator {
	public:
		iterator(const Board& board): board(board) {
			// We get the index of the center of the board
			size_t currentIdx = BOARD_SIZE % 2 == 0 ? BOARD_SIZE / 2 : (BOARD_SIZE - 1) / 2 + 1;
		}
		bool hasNext() const { return currentIdx < Board::BOARD_SIZE; }
		Gemmes* getNext();

	private :
		enum Direction { Right, Down, Left, Up, Repeat };
		int nextDirection = Right;
		size_t currentIdx;
		int steps = 1;
		int stepRepetitionLeft = 2;
		int stepsLeftBeforeTurn = 1;
		const Board& board;
	};

	iterator getIterator() const { return iterator(*this); }
};